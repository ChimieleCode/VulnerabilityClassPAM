import numpy as np
import numpy.typing as npt
from dataclasses import dataclass
from scipy.stats import norm
from typing import List


@dataclass
class FragilityModel:
    mhu: npt.NDArray[float]
    beta: npt.NDArray[float]

    def get_fragility_curves(self, IM: np.ndarray[float]) -> np.ndarray[float]:
        '''get fragility curves'''

        fragility_array = np.zeros((len(IM), len(self.mhu)))

        for i, mhu_i in enumerate(self.mhu):                                 
            fragility_array[:,i] = norm.cdf(np.log(IM / mhu_i) / self.beta[i])

        return fragility_array


@dataclass
class VulnerabilityModel:
    fragilities: FragilityModel
    damage_to_loss_model: np.ndarray[float]

    def get_vulnerability_curve(self, IM:np.ndarray) -> np.ndarray[float]:
        '''get vunerability curves'''

        fragility_curves = self.fragilities.get_fragility_curves(IM)

        prob_of_ds = np.zeros((len(fragility_curves[:,0]), len(fragility_curves[0]) + 1))

        # P(DS0)
        prob_of_ds[:,0] = 1 - fragility_curves[:,0]

        # P(DS1-DS4)
        prob_of_ds[:,1:-1] = fragility_curves[:,0:-1] - fragility_curves[:, 1:]

        # P(DS5)
        prob_of_ds[:,-1] = fragility_curves[:,-1]

        # Loss ratio
        LR_im = np.zeros(len(IM))

        for i, _ in enumerate(LR_im):

            LR_im[i] = sum(prob_of_ds[i] * self.damage_to_loss_model)

        return LR_im


@dataclass
class HazardINGV:
    MAF: List[float]
    PGA: List[float]


@dataclass
class Hazard2Order:
    k0: float
    k1: float
    k2: float

    def get_MAF(self, IM: np.array) -> np.array:
        '''return MAFs of IMs, according to a second order biased fitting of the hazard curve'''
        return self.k0 * np.exp(-self.k2 * (np.log(IM))**2 - self.k1 * np.log(IM))

    def get_dMAF(self, IM: np.array) -> np.array:
        '''return the fisrt derivative of MAFs for IMs, according to a second order biased fitting of the hazard curve'''
        return self.k0 * np.exp(-self.k2*np.log(IM)**2 - self.k1*np.log(IM)) * (-self.k2*2*np.log(IM)/IM - self.k1/IM)

    def get_IM(self, MAF: np.array) -> np.array:
        '''return the IMs corresponding to specific MAFs'''
        return np.exp((-self.k1 + (self.k1**2 - 4 * self.k2 * np.log(MAF/self.k0))**(0.5)) / (2 * self.k2))