import numpy as np
from dataclasses import dataclass
from scipy.stats import norm
from typing import List, Iterable

@dataclass
class FragilityModel:
    mhu: np.ndarray[float]
    beta: np.ndarray[float]

    def get_fragility_curves(self, IM: np.ndarray[float]) -> np.ndarray[float]:
        '''get fragility curves'''

        fragility_array = np.zeros((len(IM), len(self.mhu)))

        for i, mhu_i in enumerate(self.mhu):                                 
            fragility_array[:,i] = norm.cdf(np.log(IM / mhu_i) / self.beta[i])

        return fragility_array
    

    def get_prob_of_ds(self, IM: Iterable[float]) -> Iterable[Iterable[float]]:
        '''return probability of beeing in a specific DS, given an IM'''

        fragility_curves = self.get_fragility_curves(IM)

        prob_of_ds = np.zeros((len(fragility_curves[:,0]), len(fragility_curves[0]) + 1))

        # P(DS0)
        prob_of_ds[:,0] = 1 - fragility_curves[:,0]

        # P(DS1-DS4)
        prob_of_ds[:,1:-1] = fragility_curves[:,0:-1] - fragility_curves[:, 1:]

        # P(DS5)
        prob_of_ds[:,-1] = fragility_curves[:,-1]

        return prob_of_ds
    
@dataclass
class VulnerabilityModel:
    fragilities: FragilityModel
    damage_to_loss_model: np.ndarray[float]

    def get_vulnerability_curve(self, IM:np.ndarray) -> np.ndarray[float]:
        '''get vunerability curves'''

        prob_of_ds = self.fragilities.get_prob_of_ds(IM)

        # Loss ratio
        LR_im = np.zeros(len(IM))

        for i, _ in enumerate(LR_im):

            LR_im[i] = sum(prob_of_ds[i] * self.damage_to_loss_model)

        return LR_im
    
    
@dataclass
class RepairTimeModel:
    fragilities: FragilityModel
    damage_to_repair_time_model: Iterable[int]

    def get_repair_time_curve(self, IM:np.ndarray) -> np.ndarray[float]:
        '''get expected repair time curves'''

        prob_of_ds = self.fragilities.get_prob_of_ds(IM)

        # Repair time
        repair_time_im = np.zeros(len(IM))

        for i, _ in enumerate(repair_time_im):

            repair_time_im[i] = sum(prob_of_ds[i] * self.damage_to_repair_time_model)

        return repair_time_im
    
@dataclass
class DelayTimeModel:
    fragilities: FragilityModel
    post_erthquake_inspection_damage_to_delay_time_model: Iterable[int]
    engineering_mobilitation_damage_to_delay_time_model: Iterable[int]
    financing_damage_to_delay_time_model: Iterable[int]
    contractor_mobilitation_damage_to_delay_time_model: Iterable[int]
    permitting_damage_to_delay_time_model: Iterable[int]

    def get_delay_time_curve(self, IM:np.ndarray) -> np.ndarray[float]:
        '''get expected repair time curves'''

        prob_of_ds = self.fragilities.get_prob_of_ds(IM)

        # Repair time
        delay_time_im = np.zeros(len(IM))

        for i, _ in enumerate(delay_time_im):

            post_earthquake_delay_time = sum(prob_of_ds[i] * self.post_erthquake_inspection_damage_to_delay_time_model)
            engineering_mobilitation_delay_time = sum(prob_of_ds[i] * self.engineering_mobilitation_damage_to_delay_time_model)
            financing_delay_time = sum(prob_of_ds[i] * self.financing_damage_to_delay_time_model)
            contractor_mobilitation_delay_time = sum(prob_of_ds[i] * self.contractor_mobilitation_damage_to_delay_time_model)
            permitting_delay_time = sum(prob_of_ds[i] * self.permitting_damage_to_delay_time_model)
            
            delay_time_im[i] = post_earthquake_delay_time + max(financing_delay_time, engineering_mobilitation_delay_time + permitting_delay_time, contractor_mobilitation_delay_time)
            
        return delay_time_im


@dataclass
class TimeReOccupancyModel:
    damage_to_repair_time_model: Iterable[int]  # days
    post_erthquake_inspection: Iterable[int]
    engineering_review: Iterable[int]
    financing: Iterable[int]
    contractor_mobilization: Iterable[int]
    permitting: Iterable[int]

    beta_delay: float    # Per adesso un float
    beta_repair: float   # Per adesso un float

    def get_T_no_occ(self) -> Iterable[int]:
        '''evaluate the time spent in the no occupancy phase for each DS'''

        T_no_occ = np.zeros(len(self.damage_to_repair_time_model))

        # DSO -> no inspection is needed

        # DS1 -> only inspection
        T_no_occ[1] = self.post_erthquake_inspection[1]


        # DS2 -> inspection + 0.5 * repair time
        T_no_occ[2] = self.post_erthquake_inspection[2] +  0.5 * self.damage_to_repair_time_model[2]

        # DS3 -> inspection + max(financing, eng review + permutting, contractor mobilization) + repair
        max_delay_DS3 = max(self.financing[3], self.engineering_review[3] + self.permitting[3], self.contractor_mobilization[3])
        T_no_occ[3] = self.post_erthquake_inspection[3] + max_delay_DS3 + self.damage_to_repair_time_model[3]

        # DS4 -> inspection + max(financing, eng review + permutting, contractor mobilization) + repair/rebuilt
        max_delay_DS4 = max(self.financing[4], self.engineering_review[4] + self.permitting[4], self.contractor_mobilization[4])
        T_no_occ[4] = self.post_erthquake_inspection[4] + max_delay_DS4 + self.damage_to_repair_time_model[4]

        # DS5 -> max(financing, eng review + permutting, contractor mobilization) + rebuilt
        max_delay_DS5 = max(self.financing[5], self.engineering_review[5] + self.permitting[5], self.contractor_mobilization[5])
        T_no_occ[5] = max_delay_DS5 + self.damage_to_repair_time_model[5]

        return T_no_occ
    

    def get_beta_T_no_occ(self) -> Iterable[int]:
        '''evaluate the dispesion for time spent in the no occupancy phase for each DS'''

        # Assuming that for higher DS dispersion is lower!

        return np.array(
            [
                0,                    # DS0
                self.beta_delay,      # DS1
                self.beta_delay,      # DS2
                self.beta_delay,      # DS3
                self.beta_repair,     # DS4
                self.beta_repair      # DS5
            ]
        )
    

@dataclass
class TimeFunctionalRecoveryModel:
    damage_to_repair_time_model: Iterable[int]  # days
    post_erthquake_inspection: Iterable[int]
    engineering_review: Iterable[int]
    financing: Iterable[int]
    contractor_mobilization: Iterable[int]
    permitting: Iterable[int]
    
    beta_delay: float    # Per adesso un float
    beta_repair: float   # Per adesso un float

    water: int
    beta_water: int

    def get_T_no_funct(self) -> Iterable[int]:
        '''evaluate the time spent in the no occupancy phase for each DS'''

        T_no_funct = np.zeros(len(self.damage_to_repair_time_model))

        # DSO -> water
        T_no_funct[0] = self.water

        # DS1 -> max(water, inspection)
        T_no_funct[1] = max(self.water, self.post_erthquake_inspection[1])

        # DS2 -> max(water, inspection + max(financing, eng review + permitting, contractor mobilization) + repair)  
        max_delay_DS2 = max(self.financing[2], self.engineering_review[2] + self.permitting[2], self.contractor_mobilization[2])
        T_no_funct_repair_and_delay_DS2 = self.post_erthquake_inspection[2] + max_delay_DS2 + self.damage_to_repair_time_model[2]
        T_no_funct[2] = max(T_no_funct_repair_and_delay_DS2, self.water)

        # DS3 -> max(water, inspection + max(financing, eng review + permitting, contractor mobilization) + repair)
        max_delay_DS3 = max(self.financing[3], self.engineering_review[3] + self.permitting[3], self.contractor_mobilization[3])
        T_no_funct_repair_and_delay_DS3 = self.post_erthquake_inspection[3] + max_delay_DS3 + self.damage_to_repair_time_model[3]
        T_no_funct[3] = max(self.water, T_no_funct_repair_and_delay_DS3)

        # DS4 -> max(water,inspection + max(financing, eng review + permitting, contractor mobilization) + repair/rebuilt)
        max_delay_DS4 = max(self.financing[4], self.engineering_review[4] + self.permitting[4], self.contractor_mobilization[4])
        T_no_funct_repair_and_delay_DS4 = self.post_erthquake_inspection[4] + max_delay_DS4 + self.damage_to_repair_time_model[4]
        T_no_funct[4] = max(self.water, T_no_funct_repair_and_delay_DS4)

        # DS5 -> max(water, max(financing, eng review + permutting, contractor mobilization) + rebuilt)
        max_delay_DS5 = max(self.financing[5], self.engineering_review[5] + self.permitting[5], self.contractor_mobilization[5])
        T_no_funct_repair_and_delay_DS5 = max_delay_DS5 + self.damage_to_repair_time_model[5]
        T_no_funct[5] = max(self.water, T_no_funct_repair_and_delay_DS5)
    
        return T_no_funct
    

    def get_beta_T_no_funct(self) -> Iterable[int]:
        '''evaluate the dispesion for time spent in the no occupancy phase for each DS'''

        # Assuming that for higher DS dispersion is lower!

        return np.array(
            [
                self.beta_water,      # DS0 (water)
                self.beta_delay,      # DS1
                self.beta_delay,      # DS2
                self.beta_delay,      # DS3
                self.beta_repair,     # DS4
                self.beta_repair      # DS5
            ]
        )


@dataclass
class RecoveryPathModel:
    fragilities: FragilityModel
    T_control: int
    T_no_funct: Iterable[int]
    beta_T_no_funct: Iterable[int]

    def get_q_t_DSi(self, time: Iterable[float], ds_i: int) -> Iterable[float]:

        q_t = np.zeros(len(time))

        if self.T_no_funct[ds_i] < 0.001:
            P_no_exc = np.ones_like(time)
        
        else:
            P_no_exc = norm.cdf(np.log(time / self.T_no_funct[ds_i]) / self.beta_T_no_funct[ds_i])   # P[T_no_occ < t]

        for i, _ in enumerate(time):
            q_t[i] = 0 * (1 - P_no_exc[i]) + 1.0 * (P_no_exc[i])     # it could be modified

        # Plot
        import pylab as pl
        pl.figure(figsize=(3.35, 2.5))
        pl.plot(time, q_t*100, '-', color='k', lw=2, label='Repair')
        pl.xlabel('time [day]')
        pl.ylabel(f'q(t)|DS{ds_i} [%]')
        pl.xlim((0.0, self.T_control))
        pl.ylim((0.0, 120))
        pl.tight_layout()
        pl.savefig(f'figures/recovery_path_DS{ds_i}.png', dpi=300)
        pl.show()

        return q_t


    def get_recovery_path(self, IM: Iterable[float], time: Iterable[float]) -> np.ndarray[float]:
        '''get expected recovery path'''

        prob_of_ds = self.fragilities.get_prob_of_ds(IM)

        # Repair time
        q_t_DS0 = self.get_q_t_DSi(time, 0)
        q_t_DS1 = self.get_q_t_DSi(time, 1)
        q_t_DS2 = self.get_q_t_DSi(time, 2)
        q_t_DS3 = self.get_q_t_DSi(time, 3)
        q_t_DS4 = self.get_q_t_DSi(time, 4)
        q_t_DS5 = self.get_q_t_DSi(time, 5)

        q_t_expected = np.zeros(len(time))

        for i, _ in enumerate(time):

            q_ti_ds = np.array(
                [
                    q_t_DS0[i],
                    q_t_DS1[i],
                    q_t_DS2[i],
                    q_t_DS3[i],
                    q_t_DS4[i],
                    q_t_DS5[i]
                ]
            )

            q_t_expected[i] = sum(prob_of_ds[0] * q_ti_ds)

        return q_t_expected

@dataclass
class HazardINGV:
    MAF: List[float]
    PGA: List[float]

@dataclass
class Hazard2Order:
    k0: float
    k1: float
    k2: float

    def get_MAF(self, IM: np.array) -> np.array:
        '''return MAFs of IMs, according to a second order biased fitting of the hazard curve'''
        return self.k0 * np.exp(-self.k2 * (np.log(IM))**2 - self.k1 * np.log(IM))

    def get_dMAF(self, IM: np.array) -> np.array:
        '''return the fisrt derivative of MAFs for IMs, according to a second order biased fitting of the hazard curve'''
        return self.k0 * np.exp(-self.k2*np.log(IM)**2 - self.k1*np.log(IM)) * (-self.k2*2*np.log(IM)/IM - self.k1/IM)

    def get_IM(self, MAF: np.array) -> np.array:
        '''return the IMs corresponding to specific MAFs'''
        return np.exp((-self.k1 + (self.k1**2 - 4 * self.k2 * np.log(MAF/self.k0))**(0.5)) / (2 * self.k2))