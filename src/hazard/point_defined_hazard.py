import numpy as np
import numpy.typing as npt
from dataclasses import dataclass
from typing import Union, Iterable

from .hazard_mode_interface import HazardModel


@dataclass
class PointDefinedHazard(HazardModel):
    """

    """
    intensity_measures: Iterable[float]
    probabilities_of_exceedence: Iterable[float]

    @staticmethod
    def _validate_input(data: Union[float, int, np.ndarray]) -> np.ndarray:
        """
        Validates the input data to ensure it contains only numerical values.
        :param data: Input data to be validated.
        :return: Validated NumPy array.
        :raises TypeError: If data is not a float, int, or NumPy array.
        :raises ValueError: If data array does not contain numerical values.
        """
        if not isinstance(data, (float, int, np.ndarray)):
            raise TypeError("Input must be a float, int, or NumPy array")

        if not isinstance(data, np.ndarray):
            data = np.array([data])

        if not np.issubdtype(data.dtype, np.number):
            raise ValueError("Input data must contain numerical values")

        return data

    def probability_of_exceedance(self,
                                  intensity_measure: Union[float, int, npt.NDArray],
                                  percentile: float = .5) -> Union[float, npt.NDArray]:
        """
        Evaluates the probability of exceedance of the hazard model.
        :param intensity_measure: Intensity measure to evaluate.
        :param percentile: this implementation is not probabilistic.
        :return: Probability of exceedance.
        """
        # Saves if input is arraylike or scalar to yield a consistent output
        is_input_arraylike = isinstance(intensity_measure, np.ndarray)

        # Validate input
        intensity_measure = self._validate_input(intensity_measure)

        intensity_measure = intensity_measure.astype(float)
        # Avoid problems with logarithm
        intensity_measure[intensity_measure <= 0] = 10 ** -10

        probability = np.interp(intensity_measure, self.intensity_measures, self.probabilities_of_exceedence)

        if is_input_arraylike:
            return probability
        else:
            return probability[0]

    def d_probability_of_exceedance(self,
                                    intensity_measure: Union[float, int, npt.NDArray],
                                    percentile: float = .5) -> Union[float, npt.NDArray]:
        raise NotImplemented

    def intensity_measure(self,
                          probability: Union[float, int, npt.NDArray],
                          percentile: float = .5) -> Union[float, npt.NDArray]:
        """
        Calculates the intensity measure based on a given probability using the hazard model.
        :param probability: Probability level.
        :param percentile: this implementation is not probabilistic.
        :return: Intensity measure.
        """
        # Saves if input is arraylike or scalar to yield a consistent output
        is_input_arraylike = isinstance(probability, np.ndarray)

        # Validate input
        probability = self._validate_input(probability)

        probability = probability.astype(float)
        # Avoid problems with logarithm
        probability[probability <= 0] = 10 ** -10

        int_measure = np.interp(probability, self.probabilities_of_exceedence, self.intensity_measures)

        if is_input_arraylike:
            return int_measure
        else:
            return int_measure[0]
