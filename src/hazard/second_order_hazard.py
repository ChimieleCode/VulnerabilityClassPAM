from __future__ import annotations

import numpy as np
import numpy.typing as npt
from dataclasses import dataclass, field
from scipy.optimize import root
from typing import Union

from .hazard_mode_interface import HazardModel


@dataclass
class SecondOrderHazard(HazardModel):
    """

    """
    k0: float
    k1: float
    k2: float

    @staticmethod
    def _validate_input(data: Union[float, int, np.ndarray]) -> np.ndarray:
        """
        Validates the input data to ensure it contains only numerical values.
        :param data: Input data to be validated.
        :return: Validated NumPy array.
        :raises TypeError: If data is not a float, int, or NumPy array.
        :raises ValueError: If data array does not contain numerical values.
        """
        if not isinstance(data, (float, int, np.ndarray)):
            raise TypeError("Input must be a float, int, or NumPy array")

        if not isinstance(data, np.ndarray):
            data = np.array([data])

        if not np.issubdtype(data.dtype, np.number):
            raise ValueError("Input data must contain numerical values")

        return data

    def probability_of_exceedance(self,
                                  intensity_measure: Union[float, int, npt.NDArray],
                                  percentile: float = .5) -> Union[float, npt.NDArray]:
        """
        Evaluates the probability of exceedance of the hazard model.
        :param intensity_measure: Intensity measure to evaluate.
        :return: Probability of exceedance.
        """
        # Saves if input is arraylike or scalar to yield a consistent output
        is_input_arraylike = isinstance(intensity_measure, np.ndarray)

        # Validate input
        intensity_measure = self._validate_input(intensity_measure)

        intensity_measure = intensity_measure.astype(float)
        # Avoid problems with logarithm
        intensity_measure[intensity_measure <= 0] = 10 ** -10

        ln_intensity_measure = np.log(intensity_measure)
        # Probability of exceedence
        probability = self.k0 * np.exp(-self.k2 * ln_intensity_measure**2 - self.k1 * ln_intensity_measure)

        # Convert back to intensity measure and handle array-like vs. scalar input
        if is_input_arraylike:
            return probability
        else:
            return probability[0]

    def d_probability_of_exceedance(self,
                                    intensity_measure: Union[float, int, npt.NDArray],
                                    percentile: float = .5) -> Union[float, npt.NDArray]:
        """
        Evaluates the first derivative of the probability of exceedance of the hazard model.
        :param intensity_measure: Intensity measure to evaluate.
        :param percentile: percentile of result.
        :return: Derivative of the probability of exceedance.
        """
        # Saves if input is arraylike or scalar to yield a consistent output
        is_input_arraylike = isinstance(intensity_measure, np.ndarray)

        # Validate input
        intensity_measure = self._validate_input(intensity_measure)

        intensity_measure = intensity_measure.astype(float)
        # Avoid problems with logarithm
        intensity_measure[intensity_measure <= 0] = 10 ** -10

        # Probability of exceedence
        probability = self.probability_of_exceedance(intensity_measure)
        derivative = - probability * (2 * self.k2 * np.log(intensity_measure)/intensity_measure
                                      + self.k1 * 1 / intensity_measure)

        # Convert back to intensity measure and handle array-like vs. scalar input
        if is_input_arraylike:
            return derivative
        else:
            return derivative[0]

    def intensity_measure(self,
                          probability: Union[float, int, npt.NDArray],
                          percentile: float = .5) -> Union[float, npt.NDArray]:
        """
        Calculates the intensity measure corresponding to a given probability of exceedance.
        :param probability: Probability of exceedence
        :param percentile: percentile of result
        :return: Intensity measure
        """
        # Saves if input is arraylike or scalar to yield a consistent output
        is_input_arraylike = isinstance(probability, np.ndarray)

        # Validate input
        probability = self._validate_input(probability)

        probability = probability.astype(float)
        # Avoid problems with logarithm
        probability[probability <= 0] = 10 ** -10

        if self.k2 > 0:
            # Finds intensity measure
            # If k2 is negative, then i look for the lower value of the solution
            exponent = (-self.k1 + np.sqrt(self.k1**2 - 4 * self.k2 * np.log(probability/self.k0))) / (2 * self.k2)
            intensity_measure = np.exp(exponent)
        else:
            intensity_measure = probability / self.k0 * np.exp(-self.k1)

        # Convert back to intensity measure and handle array-like vs. scalar input
        if is_input_arraylike:
            return intensity_measure
        else:
            return intensity_measure[0]

    @property
    def max_probability(self) -> float | None:
        """Returns the maximum probability of exceedance"""
        if self.k2 <= 0:
            return None
        return self.k0 * np.exp(self.k1**2 / (4 * self.k2))


def modify_hazard_curve(hazard: SecondOrderHazard, amp_factor: float) -> SecondOrderHazard:
    """
    Modifies a hazard curve to consider the effects of local response such as soil type and topographic amplification
    factors
    :param hazard: second order interpolation hazard curve
    :param amp_factor: amplification factor relative to the original hazard model
    :return:
    """
    # modification factor is the log of the inverse of the amplification factor
    mod_factor = -np.log(amp_factor)

    return SecondOrderHazard(
        k0=hazard.k0 * np.exp(-hazard.k2 * mod_factor**2 - hazard.k1 * mod_factor),
        k1=hazard.k1 + 2 * hazard.k2 * mod_factor,
        k2=hazard.k2
    )


