import numpy as np
import numpy.typing as npt
from dataclasses import dataclass
from scipy.optimize import root
from typing import Union

from .hazard_mode_interface import HazardModel


@dataclass
class SecondOrderHazard(HazardModel):
    """

    """
    k0: float
    k1: float
    k2: float

    @staticmethod
    def _validate_input(data: Union[float, int, np.ndarray]) -> np.ndarray:
        """
        Validates the input data to ensure it contains only numerical values.
        :param data: Input data to be validated.
        :return: Validated NumPy array.
        :raises TypeError: If data is not a float, int, or NumPy array.
        :raises ValueError: If data array does not contain numerical values.
        """
        if not isinstance(data, (float, int, np.ndarray)):
            raise TypeError("Input must be a float, int, or NumPy array")

        if not isinstance(data, np.ndarray):
            data = np.array([data])

        if not np.issubdtype(data.dtype, np.number):
            raise ValueError("Input data must contain numerical values")

        return data

    def probability_of_exceedance(self, intensity_measure: Union[float, int, npt.NDArray]) -> Union[float, npt.NDArray]:
        """
        Evaluates the probability of exceedance of the hazard model.
        :param intensity_measure: Intensity measure to evaluate.
        :return: Probability of exceedance.
        """
        # Saves if input is arraylike or scalar to yield a consistent output
        is_input_arraylike = isinstance(intensity_measure, np.ndarray)

        # Validate input
        intensity_measure = self._validate_input(intensity_measure)

        intensity_measure = intensity_measure.astype(float)
        # Avoid problems with logarithm
        intensity_measure[intensity_measure <= 0] = 10 ** -10

        ln_intensity_measure = np.log(intensity_measure)
        # Probability of exceedence
        probability = self.k0 * np.exp(-self.k2 * ln_intensity_measure**2 - self.k1 * ln_intensity_measure)

        # Convert back to intensity measure and handle array-like vs. scalar input
        if is_input_arraylike:
            return probability
        else:
            return probability[0]

    def intensity_measure(self, probability: Union[float, int, npt.NDArray]) -> Union[float, npt.NDArray]:
        """
        Calculates the intensity measure corresponding to a given probability of exceedance.
        :param intensity_measure:
        """

        raise NotImplemented
