import numpy as np
import numpy.typing as npt

from dataclasses import dataclass
from typing import Union, List

from .loss_model_interface import LossModel

from ..hazard import HazardModel
from ..vulnerability import VulnerabilityModel


@dataclass
class LossImplementation(LossModel):
    hazard: HazardModel
    vulnerability: VulnerabilityModel

    @staticmethod
    def _validate_input(data: Union[float, int, np.ndarray]) -> np.ndarray:
        """
        Validates the input data to ensure it contains only numerical values.
        :param data: Input data to be validated.
        :return: Validated NumPy array.
        :raises TypeError: If data is not a float, int, or NumPy array.
        :raises ValueError: If data array does not contain numerical values.
        """
        if not isinstance(data, (float, int, np.ndarray)):
            raise TypeError("Input must be a float, int, or NumPy array")

        if not isinstance(data, np.ndarray):
            data = np.array([data])

        if not np.issubdtype(data.dtype, np.number):
            raise ValueError("Input data must contain numerical values")

        return data

    def loss(self,
             probability: Union[int, float, npt.NDArray],
             percentile: float = .5) -> Union[float, npt.NDArray]:
        """
        Evaluates the probability of exceedance of the hazard model.
        :param probability: Probability of exceedance.
        :param percentile: Probability of exceedence of the result.
        :return: related loss.
        """
        # Saves if input is arraylike or scalar to yield a consistent output
        is_input_arraylike = isinstance(probability, np.ndarray)

        # Validate input
        probability = self._validate_input(probability)

        probability = probability.astype(float)

        # Avoid problems with logarithm
        probability[probability <= 0] = 10 ** -10

        intensity_measure = self.hazard.intensity_measure(probability, percentile)
        losses = self.vulnerability.loss(intensity_measure, percentile)

        # Convert back to intensity measure and handle array-like vs. scalar input
        if is_input_arraylike:
            return losses
        else:
            return losses[0]

    def expected_annual_loss(self, min_maf: float, max_maf: float, percentile: float = .5, steps: int = 10000) -> float:
        """
        Computes expected annual loss from min to max maf
        :param min_maf: minimum MAF (Mean Annual Frequency) to consider
        :param max_maf: maximum MAF (Mean Annual Frequency) to consider
        :param percentile: percentile of the result
        :param steps: number of im to consider
        :return: EAL
        """
        mean_annual_frequencies = np.linspace(min_maf, max_maf, steps)

        losses = self.loss(mean_annual_frequencies, percentile)
        expected_annual_loss = np.trapz(losses, mean_annual_frequencies)

        return expected_annual_loss

#%%
