import numpy as np
import numpy.typing as npt
from dataclasses import dataclass
from typing import Union
from scipy.stats import beta

from .lossratio_interface import LossRatioModel


@dataclass
class BetaLossRatio(LossRatioModel):
    """
    Represents a loss ratio model using the beta_ distribution.

    Attributes:
    - mean_: The mean_ parameter of the beta_ distribution representing the loss ratio.
    - cov_: The covariance parameter of the beta_ distribution representing the loss ratio.

    Methods:
    - mean: Returns the mean_ parameter of the beta distribution.
    - cov: Returns the covariance parameter of the beta distribution.
    - probability_of_exceedance: Calculates the probability of exceedance of the loss ratio based on the beta_ distribution.
    - loss_ratio: Calculates the loss ratio corresponding to a given probability level using the inverse of the beta_ distribution.
    """
    mean_: float
    cov_: float

    @property
    def mean(self) -> float:
        """Returns the mean_ parameter of the beta_ distribution."""
        return self.mean_

    @property
    def cov(self) -> float:
        """Returns the covariance parameter of the beta_ distribution."""
        return self.cov_

    @staticmethod
    def _validate_input(data: Union[int, float, npt.NDArray]) -> np.ndarray:
        """Validate input data to ensure it contains only numerical values and is within [0, 1] range."""
        if isinstance(data, (int, float)):
            data = np.array([data])
        elif not isinstance(data, np.ndarray):
            raise TypeError("Input must be a float, int, or NumPy array")

        if not np.issubdtype(data.dtype, np.number):
            raise ValueError("Input data must contain numerical values")

        if np.any((data < 0) | (data > 1)):
            raise ValueError("Input data values must be within [0, 1] range")

        return data.astype(float)

    def probability_of_exceedance(self, loss_ratio: Union[int, float, npt.NDArray]) -> Union[float, npt.NDArray]:
        """
        Calculates the probability of exceedance of the loss ratio based on the beta_ distribution.
        :param loss_ratio: The loss ratio value or an array of loss ratio values.
        :return: The probability or an array of probabilities that the loss ratio exceeds the given value(s).
        """
        validated_loss_ratio = self._validate_input(loss_ratio)

        # Calculate parameters for the beta_ distribution
        alpha = (1 - self.mean) / self.cov ** 2 - self.mean
        beta_param = alpha * (1 - self.mean) / self.mean

        # Calculate the probability of exceedance using the beta_ cumulative distribution function (CDF)
        if isinstance(loss_ratio, np.ndarray):
            return beta.cdf(validated_loss_ratio, alpha, beta_param)
        else:
            return beta.cdf(validated_loss_ratio, alpha, beta_param)[0]

    def loss_ratio(self, probability: Union[int, float, npt.NDArray]) -> Union[float, npt.NDArray]:
        """
        Calculates the loss ratio corresponding to a given probability level using the inverse of the beta_ distribution.
        :param probability: The probability level or an array of probability levels.
        :return: The corresponding loss ratio value(s) for the given probability level(s).
        """
        validated_probability = self._validate_input(probability)

        # Calculate parameters for the beta_ distribution
        alpha = (1 - self.mean) / self.cov ** 2 - self.mean
        beta_param = alpha * (1 - self.mean) / self.mean

        # Calculate the loss ratio using the inverse of the beta_ cumulative distribution function (CDF)
        if isinstance(probability, np.ndarray):
            return beta.ppf(validated_probability, alpha, beta_param)
        else:
            return beta.ppf(validated_probability, alpha, beta_param)[0]


