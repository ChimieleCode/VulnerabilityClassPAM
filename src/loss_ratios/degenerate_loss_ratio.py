import numpy as np
import numpy.typing as npt
from dataclasses import dataclass
from typing import Union

from .lossratio_interface import LossRatioModel


@dataclass
class DegenerateLossRatio(LossRatioModel):
    """
    Represents a loss ratio model using a deterministic model.

    Attributes:
    - mean_: The mean_ parameter of the beta_ distribution representing the loss ratio.

    Methods:
    - mean: Returns the mean_ parameter.
    - cov: Returns the covariance parameter of the distribution, which is 0.
    - probability_of_exceedance: Calculates the probability of exceedance of the loss ratio.
    - loss_ratio: Calculates the loss ratio corresponding to a given probability level.
    """
    mean_: float

    @property
    def mean(self) -> float:
        return self.mean_

    @property
    def cov(self) -> float:
        return 0

    @staticmethod
    def _validate_input(data: Union[int, float, npt.NDArray]) -> np.ndarray:
        """Validate input data to ensure it contains only numerical values and is within [0, 1] range."""
        if isinstance(data, (int, float)):
            data = np.array([data])
        elif not isinstance(data, np.ndarray):
            raise TypeError("Input must be a float, int, or NumPy array")

        if not np.issubdtype(data.dtype, np.number):
            raise ValueError("Input data must contain numerical values")

        if np.any((data < 0) | (data > 1)):
            raise ValueError("Input data values must be within [0, 1] range")

        return data.astype(float)

    def probability_of_exceedance(self, loss_ratio: Union[int, float, npt.NDArray]) -> Union[float, npt.NDArray]:
        """
        Returns 0 if loss ratio is below the median, returns 1 if above or equal.
        :param loss_ratio: The loss ratio value or an array of loss ratio values.
        :return: The probability or an array of probabilities that the loss ratio exceeds the given value(s).
        """
        validated_loss_ratio = self._validate_input(loss_ratio)

        probability = validated_loss_ratio
        # 0 if less then the mean value
        probability[probability < self.mean_] = 0
        # 1 if more than the mean value
        probability[probability >= self.mean_] = 1

        # Calculate the probability of exceedance using the beta_ cumulative distribution function (CDF)
        if isinstance(loss_ratio, np.ndarray):
            return probability
        else:
            return probability[0]

    def loss_ratio(self, probability: Union[int, float, npt.NDArray]) -> Union[float, npt.NDArray]:
        """
        Returns the median, always.
        :param probability: The probability level or an array of probability levels.
        :return: The corresponding loss ratio value(s) for the given probability level(s).
        """
        validated_probability = self._validate_input(probability)

        # Calculate the loss ratio using the inverse of the beta_ cumulative distribution function (CDF)
        if isinstance(probability, np.ndarray):
            return np.full(validated_probability.shape, self.mean_)
        else:
            return self.mean_

