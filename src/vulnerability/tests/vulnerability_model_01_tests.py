import unittest
import numpy as np

from ..vulnerability_model_01 import VulnerabilityImplementation, VulnerabilityDamageState

from ...loss_ratios import BetaLossRatio
from ...fragility import SimpleLogNormalFragility


class TestVulnerabilityImplementation1(unittest.TestCase):

    def setUp(self):
        # Initialize the VulnerabilityImplementation object with test data
        frag_model = SimpleLogNormalFragility(beta_=1.0, mu=2.0)
        loss_model = BetaLossRatio(mean_=0.5, cov_=0.2)
        self.vulnerability_impl = VulnerabilityImplementation([VulnerabilityDamageState(frag_model, loss_model)])
        pass

    def test_close_to_zero_intensity_measure(self):
        # Test if the loss is close to 0 when the intensity_measure is close to 0
        intensity_measure = 0  # Example close to zero value
        result = self.vulnerability_impl.loss(intensity_measure)
        self.assertAlmostEqual(result, 0, delta=10**-9)  # Adjust delta as needed

    def test_int_input(self):
        # Test for an integer input
        intensity_measure = 5  # Example integer value
        result = self.vulnerability_impl.loss(intensity_measure)
        self.assertIsInstance(result, float)  # Ensure the result is of type float

    def test_float_input(self):
        # Test for a float input
        intensity_measure = 3.14  # Example float value
        result = self.vulnerability_impl.loss(intensity_measure)
        self.assertIsInstance(result, float)  # Ensure the result is of type float

    def test_numpy_array_input(self):
        # Test for a NumPy array input
        intensity_measure = np.array([1, 2, 3])  # Example NumPy array
        result = self.vulnerability_impl.loss(intensity_measure)
        self.assertIsInstance(result, np.ndarray)  # Ensure the result is a NumPy array

    def test_non_numeric_values_in_numpy_array(self):
        # Test if ValueError is raised for non-numeric values in the NumPy array
        intensity_measure = np.array([1, 'a', 3])  # Array containing non-numeric value 'a'
        with self.assertRaises(ValueError):
            self.vulnerability_impl.loss(intensity_measure)

    def test_invalid_input_type(self):
        # Test if TypeError is raised for invalid input types
        invalid_inputs = ['string', None, {'key': 'value'}, True]  # Example invalid inputs
        for input_val in invalid_inputs:
            with self.assertRaises((TypeError, ValueError)):
                self.vulnerability_impl.loss(input_val)

    def test_percentile_comparison(self):
        # Test if using a lower percentile yields a lower value than the default percentile
        intensity_measure = 10  # Example intensity measure value
        result_default_percentile = self.vulnerability_impl.loss(intensity_measure)
        result_lower_percentile = self.vulnerability_impl.loss(intensity_measure, percentile=0.16)
        result_higher_percentile = self.vulnerability_impl.loss(intensity_measure, percentile=0.84)

        self.assertGreater(result_higher_percentile, result_default_percentile,
                           "Using a higher percentile did not yield a higher value than the default.")

        self.assertLess(result_lower_percentile, result_default_percentile,
                        "Using a lower percentile did not yield a lower value than the default.")


class TestVulnerabilityImplementation2(unittest.TestCase):

    def setUp(self):
        # Initialize the VulnerabilityImplementation object with test data for two damage states
        frag_model_1 = SimpleLogNormalFragility(beta_=1.0, mu=2.0)
        loss_model_1 = BetaLossRatio(mean_=0.5, cov_=0.2)
        frag_model_2 = SimpleLogNormalFragility(beta_=0.8, mu=1.5)
        loss_model_2 = BetaLossRatio(mean_=0.3, cov_=0.15)

        damage_state_1 = VulnerabilityDamageState(frag_model_1, loss_model_1)
        damage_state_2 = VulnerabilityDamageState(frag_model_2, loss_model_2)

        self.vulnerability_impl = VulnerabilityImplementation([damage_state_1, damage_state_2])

    def test_sorting_of_damage_states(self):
        # Test if damage states are sorted by fragility mean in ascending order
        frag_means = [state.fragility.mean for state in self.vulnerability_impl.damage_states]
        self.assertEqual(sorted(frag_means), frag_means,
                         "Damage states are not sorted in ascending order of fragility means.")

    def test_values_between_zero_and_one(self):
        # Test if the values yielded by the loss method are always between 0 and 1
        intensity_measure = 10  # Example intensity measure value
        result = self.vulnerability_impl.loss(intensity_measure)
        self.assertTrue(0 <= result <= 1,
                        "Value yielded by loss method is not between 0 and 1.")

    def test_values_between_zero_and_one_array(self):
        # Test if the values yielded by the loss method for an array of intensity measures are between 0 and 1
        intensity_measures = np.array([5, 10, 15])  # Example array of intensity measures
        results = self.vulnerability_impl.loss(intensity_measures)

        for result in results:
            self.assertTrue(0 <= result <= 1,
                            "Value yielded by loss method is not between 0 and 1 for array input.")

