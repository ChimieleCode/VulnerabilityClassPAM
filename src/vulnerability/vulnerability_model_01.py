import numpy as np
import numpy.typing as npt
from dataclasses import dataclass
from typing import Union, List

from .vulnerability_interface import VulnerabilityModel

from ..fragility import FragilityModel
from ..loss_ratios import LossRatioModel


@dataclass
class VulnerabilityDamageState:
    fragility: FragilityModel
    losses: LossRatioModel


@dataclass
class VulnerabilityImplementation(VulnerabilityModel):
    damage_states: List[VulnerabilityDamageState]

    def __post_init__(self):
        self.damage_states.sort(key=lambda x: x.fragility.mean)

    def loss(self,
             intensity_measure: Union[int, float, npt.NDArray],
             percentile: float = .5) -> Union[float, npt.NDArray]:

        if len(self.damage_states) == 1:
            # Handle calculation for a single damage state
            frag = self.damage_states[0].fragility
            loss_model = self.damage_states[0].losses
            return frag.probability_of_exceedance(intensity_measure) * loss_model.loss_ratio(percentile)

        # Rest of the calculation for multiple damage states
        loss_ = 0
        for dmg_state, next_dmg_state in zip(self.damage_states[:-1], self.damage_states[1:]):
            frag, next_frag = dmg_state.fragility, next_dmg_state.fragility
            loss_model = dmg_state.losses
            loss_ += loss_model.loss_ratio(percentile) \
                     * (frag.probability_of_exceedance(intensity_measure)
                        - next_frag.probability_of_exceedance(intensity_measure))

        last_frag = self.damage_states[-1].fragility
        last_loss_model = self.damage_states[-1].losses
        loss_ += last_frag.probability_of_exceedance(intensity_measure) * last_loss_model.loss_ratio(percentile)

        return loss_
